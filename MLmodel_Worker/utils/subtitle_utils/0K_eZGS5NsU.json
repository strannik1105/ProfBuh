{
    "0": [
        "Привет всем, добро пожаловать обратно, и давайте писатьнемного более классного кода сегодня. Так что сегодня я хочу рассказать вам все, чтовам нужно знать о Python для кодирования интервью. ",
        "00:00:00,00"
    ],
    "1": [
        "Если вы новичок, немного о моем объяснении. Я начал канал несколько лет назад, в началепандемии. Я был безплатным, и я сделал решения для кодированияинтервью в Python. И немного более чем год после этого я в итоге получилработу в Google, и я практически использовал Pythonво всех моих интервью, и я думаю, что это былодействительно полезно, потому что Python таклегко, чем в большинстве языков, и это супер конкретно. Я вообще никогда не писал линию кода Pythonв каких-либо работах или интервью, которые яникогда делал. Я буквально учил Python только для кодированияинтервью, и это было действительно важно. Если вы уже знакомы с Python, я надеюсь, что выузнали некоторые советы и трюки из этоговидео, и если вы используете другие языки, как Javaили C++, я надеюсь, что в конце этого видео выувидите плюсы и затем присоединитесь кцеркви Python. Я думаю, что вы сможете улучшить это быстрее, чемвы ожидали, особенно если вы уже знакомыс программой. ",
        "00:00:08,48"
    ],
    "2": [
        "И, кстати, если вы изучаете кодированиеинтервью, посмотрите на neatcode. io, это сайт, которыйя создал, и он имеет много бесплатныхресурсов, чтобы помочь вам подготовиться. И я также начал делать курсы. Я только что закончил курс на предаваемыеалгоритмы, и я буду начинать курс насистемное дизайн для начинающих, так чтовы не хотите пропустить это. Окей, давайте начнем. ",
        "00:00:56,36"
    ],
    "3": [
        "Первое, что вы должны знать о Python, этото, что это динамично-тайповая язык. Так что, когда мы заявляем вариант, например,n, и ставим его на 0, мы не должнызаявлять тип вообще. Так что теперь, если мы запустим код изапишем n, вы можете увидеть, что это равен 0. Но типы определяются в время работы, так чтомы можем переносить n на стринг, и этоидеально, потому что n не имеет типа. Тип определяется в время работы. ",
        "00:01:12,88"
    ],
    "4": [
        "Так что теперь мы можем снова запустить код,и мы можем увидеть, что n был оригинально 0,и потом он изменился на стринг ABC. Мы также можем делать множествозаявлений, но это немного другое, чемв большинстве языков. Если у нас есть два варианта, мыставим их оба на левой стороне, ипотом мы имеем нашу равную, и потоммы ставим два значения на левой стороне. Непросто, чтобы иметь множество типов водной линии. Инкрементация немного другая. Конечно, мы можем инкрементировать вочень простой способ, как это. ",
        "00:01:36,92"
    ],
    "5": [
        "n равен n плюс 1. Мы также можем делать короткую руку n плюсравен 1, как и в большинстве языков, номы не можем делать плюс плюс. Вы можете увидеть, что это даже дает намошибку в синтезе. ",
        "00:02:05,44"
    ],
    "6": [
        "Мы не можем делать плюс плюс. Это связано с интерпретером Python,но это не очень важно. Я имею в виду, что это один изслучаев, когда Python немного менееконкретен. Python также имеет ноль, но это называетсяноль в Python, что, в основном, являетсяотсутствием цифры. В отличие от большинства языков, мы можемиметь цифру, которая вначале является цифрой,или она должна содержать цифру, как 4,но потом мы можем ее переносить в ноль,что означает ноль, и потом мы видим, чтоона равна ноли. ",
        "00:02:15,08"
    ],
    "7": [
        "If-представления довольнопростые в Python, хотя быконцептуально, но синтетически. Есть несколько различий, в том числе,что нам не нужны парентезы, поэтому еслиу нас есть If-представление, как это, мыне нужны вставить кондиционер в парентезы,и мы не нужны крылья, чтобыпредставлять, что это блок, которыйсоответствует этому кондиционеру. Мы используемвкладку для этого, так что вы можете видеть,что у нас есть кнопка, котораяозначает, что этот код принадлежитэтому предсказанию. У нас есть колонна, которыйидет после кондиционера. ",
        "00:02:39,52"
    ],
    "8": [
        "Else-if работает немногопо-другому. Мы не имеем обоихключевых слов Else-if, мы дажесокращаем это. Я не оченьзаботился о этом, но я предполагаю, что этопросто связано сPython-интерпретером, потому что у нас ужеесть два ключевых слова для If и Else,поэтому мы должны создать новый ключевыйслово для Else-if, по крайней мере, это то,что я предполагаю. Парентезы ненужны для кондиционеров в Python,они нужны, если у нас естьмульти-лайны кондиционеров. ",
        "00:03:07,56"
    ],
    "9": [
        "И, кстати,Logic-and в большинстве языков являетсядвумя-персиметровымхарактером, но в Python это простоключевое слово and, or это простоключевое слово or. Так что не то, что этокороче, но это просто делает вещинемного более читательными. Синтетически,while-лупы довольно похожи,например, у нас естьпараметра n == 0, мы можемсоздать while-луп, гдекондиционер не долженидти в парентезы, блокподсоединен к колонне, икод сам по себевключен с кнопкой, мыпринимаем n, и, используя код,мы получаем 0-4. И, используя код, вы увидите, что мы получаемпочти то же самое, 0-4,так что 5 не включенв процессе выполнения лупы. Чтобы лучше изображать 4-луп, давайтепосмотрим на другой пример, где мы идемот 2 до 5. В этом случае мы используем те жекоди, для i в паренте, номы вводим 2 варианта в паренте,мы начинаем с 2,и идем до 6,но не включая 6,так что теперь, когда мы запишем это,мы идем от 2 до5.  И если вы хотитеидти в обратном направлении, начиная с 5и идти до 2, то это будетпохоже.  Мы начнем с 5,мы идем до 1,но не включая 1, и мывводим 1-1 как 3-йаргумент, потому что в этом случаемы ограничиваем. ",
        "00:03:30,00"
    ],
    "10": [
        " Если вы не вводите1-1, мы увеличиваем i,но когда вы вводите 1-1,это означает, что мы ограничиваем i. И мы могли бы вводить 2-2здесь, если мы хотели ограничить2 каждый раз, но просто ограничиваяэто, идем от 5 до 2,и вы можете увидеть, что мы получили, что мы ожидали. Я предполагаю, что это было одной изнегативных вещей, когда я первый раз учил пайтон. Ограничение также немного сложное впайтоне, это декимальная ограничениепо правде, а большинство языковиспользуют ограничение интеграции, так что5 разделить на 2 будет действительно дать2. 5, а в большинстве языковэто будет обращаться к 0по правде. ",
        "00:05:29,68"
    ],
    "11": [
        "5, в большинстве языковэто будет 1.  Делатьэто нужно, чтобы использоватьограничение декимальных, но затем перевести результатк интеграции, потому что когда вы переводитек интеграции, он обращаетсяк 0. Вы можете увидеть, что это будет дать нам негативную1, что может быть вам нужным в некоторых случаях. Хотя я бы сказал, что это довольно редко, что нужно знатьэто, я просто напоминаю, в случае, если вы попадаетев какие-то проблемы. Использование модуля оператора довольно похоже набольшинство языков, так что 10 разделено 3, получаяостальное, мы ожидали 1, и это именно то, что мы получаем. Кроме того, проблема, опять же, с негативными валютами. Как и разделение негативных валют, когда мы модируемнегативные валюты, мы получаем неожиданные результаты, и10 разделено 3, ну, ответ на это, на самом деле, 2. ",
        "00:06:49,68"
    ],
    "12": [
        "И это другое, чем большинство языков, основанных на C,например, Java, C++, я думаю, даже JavaScript. Так что если вы хотите быть консистентными сэтими другими языками, вы можете импортировать математику иделать f-mods. Использование этого дает нам негативную 1, что,возможно, вы и ожидали. Несколько полезных математических помощников. ",
        "00:00:33,48"
    ],
    "13": [
        "У нас есть Floor, который выясняет, что мы делаем. Мы можем также делать отличие, что является крышкой,так что 3 разделено 2, оборачивая. Если вам нужно взять квадратную линзу, то есть помощник,и если вам нужно взять мощь вариабла, вывесивее к другим, так что 2 в мощи 3, это будет это. ",
        "00:07:11,68"
    ],
    "14": [
        "Если вам нужно максимум, вы можете использоватьfloat-инфинит, и если вам нужно минимум, вы можетеиспользовать float-негативный-инфинит. И часть причины, почему они появляются, это потому,что пайтонские числа неисполненные, так что онивообще никогда не пропадают. Так что если у нас есть число, как это, 2 в мощи 200,это очень большое число, как вы можете видетьна правом конце, после того, как мы его запишем. Это так большое, что мы даже не можем его запишать,это 60 дополнительных дигиталей, но даже это большое числовсе еще меньше, чем инфинит. Читая, если это число меньше, чем инфинит, мы получаемверность. ",
        "00:07:11,68"
    ],
    "15": [
        "Arrays, которые называются листы в пайтоне,это, наверное, самый распространенный данныйструктурой, которую вы используете в связи с хаш-мапами. Так что аррэй может быть заявлен таким образом,но вначале он довольно простой. Вы просто вкладываете цифры в несколько бракетови записывание их просто так просто. ",
        "00:01:40,12"
    ],
    "16": [
        "Arrays в пайтоне это динамические аррэи по правилам. Так что, как и в большинстве языков, динамическиеаррэи могут быть использованы как листы. Так что вы можете поддержать аррэю, аккордонноAppend, и вы можете также поддержать аррэю, котораяподдержит от конца, конечно. Так что после того, как мы поддержим 4 и 5, мы можемзаписать это, и после того, как мы поддержим последнююцифру, вы можете видеть, что мы поддержим 5. Так как это технически аррэй, а не стак, мы можемвкладывать в миддл. ",
        "00:04:41,68"
    ],
    "17": [
        "Так что в Index 1 мы можем вкладывать 7. Продавая это, вы можете видеть, что мы вкладывали7 в миддл аррэя. Но не так, как выкладывая и выкладывая из аррэя,вкладывание в миддл это большая операцияEndTime. Но это не большая операция EndTime, чтобы вкладыватьаррэю. ",
        "00:02:23,00"
    ],
    "18": [
        "Так что в Index 0 мы можем читать валюту, и мы можемтакже вкладывать валюту в 0 в этом случае, и мыможем вкладывать валюту в Index 3. И эти операции это ConstantTime. Чтобы вкладывать в аррэю значительную цифру,скажем, мы хотели вкладывать в аррэю значительную5, и мы хотели, чтобы все валюты были 1, мы моглиэто сделать довольно легко. Это может быть немного странным, чтобы использоватьоператор мультипликации, но синтактически этодовольно легко. Продавая аррэю и длину аррэя, вы можете видеть,что мы получаем то, что мы ожидаем. ",
        "00:02:42,08"
    ],
    "19": [
        "Но будьте осторожны, когда выкладываете в аррэю,особенно когда вы используете негативные валюты,потому что негативная 1 не является выводом изпаузы в Python. Негативная 1 будет читать последнюю валюту, как выможете видеть на правом экране. И чтобы читать вторую последнюю валюту, вы можетеиспользовать негативную 2. В моем мнении, это не очень полезно, но иногдаэто может быть, когда вы хотите быстро читатьпоследнюю валюту. ",
        "00:03:10,72"
    ],
    "20": [
        "Добавление SubLists, то есть выкладывание в аррэю,это одна из самых полезных функций в Python. Так что здесь мы берем валюты в аррэе с Index 1до Index 3, но не включая Index 3, как ис 4-ми лупами, и потом выкладывание этих валют. Так что мы ожидали 2 и 3, и вот что мы получили. И мы также можем идти с Index 0 до 4, что довольномного всего в аррэе, и это тоже валидно. ",
        "00:03:32,60"
    ],
    "21": [
        "Unpacking тоже очень полезная функция. В основном, мы можем взять все индивидуальные элементыаррэя и присоединять их к вариаблям, в этом случаеABC. Это может быть очень полезно, когда вы хотитепройти по списку пар, например. Будьте осторожны, потому что вы должны убедиться,что количество вариаблов на левой стороне соответствуетколичеству, который вы ожидаете от аррэя. Мы можем пройти по аррэю в много разныхспособах. Используя простую 4-ми лупную синтезацию, которуюмы говорили об этом ранее, мы можем взять длинуаррэя и потом итерировать ее так много раз, используяIndex i, и потом выкладывая индивидуальный валют. Лучше выполнить тот же самое, безиспользования Index, так что мы можем пройти по всемувариаблю в NUM и потом просто изображать тот индивидуальныйвалют. ",
        "00:07:11,68"
    ],
    "22": [
        "Если по какой-то причине вам понадобилсяIndex и вариабль, вы могли использовать первый 4-ми луп,который я показал здесь, но другой способиспользовать это, это использовать функцию Enumerateв Python. И Enumerate будет дать вам Index, который будетпервым вариаблем, который будет распакованным, ивторой вариабль, который будет распакованным, будетчисло, и потом мы можем изображать оба из них, еслипо какой-то причине нам понадобилось оба из них. И все три этих вариабля выполняются, как выожидали. ",
        "00:04:42,84"
    ],
    "23": [
        "Если мы хотим пройти по многим вариаблямодновременно, мы можем сделать это с распаковкой ипомощью, которая называется Zip. Zip будет, в основном, взять оба этих вариабля исмешать их в вариабль пар, и потом мы можем распаковатьэти пары валют, которые вариабли из NUM1 и NUM2. Мы получаем, что мы и ждем. Отвергнуть вариабль так просто, как называтьответственную методику на этот вариабль. ",
        "00:05:07,20"
    ],
    "24": [
        "Итак, 123 становится 321. Сортировать вариабль так просто. Возьмем этот вариабль, мы можем назвать его Sort, иэто будет сортировать в нисходящем порядке поправилам. Если мы хотим сортировать его в обратном порядке,мы просто вводим параметр reverse=\"true\", ипотом вариабль будет сортирован в нисходящемпорядке. Мы также можем сортировать список стрингов. По правилам они будут сортированы в алфавитномпорядке, как вы видите на правом. Но если мы хотим выполнять кустомный сорт, например,если мы хотим сортить по длине каждого стринга,то мы можем сделать это, вводя в него ламбда. Так что в этом случае ключ равен ламбде, которыйв основном функции без имени, и мы будем взятькаждый синий вариант из аррея, называть егоx, и потом вернуть из этого длину x, и этоключ, который будет использоваться для сортировкистринга. Так что каждый стринг будет сформирован по длине,и потом мы будем сортировать эти стринги по длине. По правилам, это будет в восстановленном порядке,как мы можем подтвердить на правом. ",
        "00:05:34,16"
    ],
    "25": [
        "Еще один способ, как сортировать списки, этоиспользование компреенсии списка. Так что если мы хотели пройти через каждыйвариант в длине 5, и называть этот вариант i, и мы хотимдобавить этот вариант в этот арре, это короткоедело. Так что мы итерируем для i в длине 5, и потом iидет сюда, так что мы берем этот i-вариант и добавляемего в арре. И при печатании вы можете увидеть, что мы действительно0 through 4. Now, maybe we want to go through every value in that range, but we want to take i and addi plus i to the result. So for every index, we want two times that index added to the result. ",
        "00:07:11,68"
    ],
    "26": [
        "You can see we can also do that pretty easily. If you want to do something similar for a 2D list, it's also pretty easy, but maybe a bitdifferent than you would expect. The easiest way to do it is the shorthand that we talked about earlier, where we takean array with 0 and then multiply it by 4. This will give us an array of size 4 with all 0s. And we want this array to be added to the outer array four times. So we have an inner loop for i in range 4. We're not even using the variable i here, but this will build a 4 by 4 grid of all 0s. You might be thinking, isn't there an easier way to do that. ",
        "00:00:12,84"
    ],
    "27": [
        "Well, actually not. You might be thinking, can we just do this, create an array of size 4, and then multiplythat by 4. Well, technically this will work, but each of the four rows of this array are going tobe the same. So if we modify one of the rows, we're going to be modifying all of the other rows. We're not actually creating four unique rows in this case. It's a common thing that can throw people off. ",
        "00:00:49,72"
    ],
    "28": [
        "If you have more questions about this, feel free to ask in the comments. It's something that tripped me up a lot when I first started. Strings are pretty similar to arrays, so we can declare one with double quotes. You can also use single quotes if you want. And we can slice them the same way we do with arrays. And printing it works the same. But a key point is that they are immutable. That means we can't modify the string. That means we can't reassign the character at index 0. We can, however, update the string, but updating it will actually create a new string. So adding def to the end of the string will create a new string. ",
        "00:01:14,02"
    ],
    "29": [
        "So basically, any time you modify a string, it's considered an end time operation. Strings can be converted into integers, and then those integers can be added. Integers can also be converted into strings, and then those strings can be added together. ",
        "00:01:50,24"
    ],
    "30": [
        "So when you add two integers together, we get an integer as a result. Adding two strings together appends those strings together. So we get 1, 2, 3, 1, 2, 3. ",
        "00:02:06,22"
    ],
    "31": [
        "If for some reason you need the ASCII value of a character, you can do that with the ORDfunction. So if we do this, you can see we get 97 is the ASCII value of lowercase a, 98 is theASCII value of lowercase b. You can also join a list of strings together with a delimiter. In this example, we have three strings, and we're joining them with the empty string delimiterhere. So we're basically just appending these three strings together. We could also have had a delimiter, maybe a space in between all of them. And printing the result, we get all three strings appended. Queues in Python are double-ended queues by default. ",
        "00:02:15,50"
    ],
    "32": [
        "You can import them. Adding values to the right side is as easy as appending to the queue. So at this point, our queue isn't much different from a stack. But the benefit is that we can actually pop from the left of the queue, and we can dothis operation in constant time, unlike with a stack, as you can confirm on the right. Since it's double-ended, we can also add values to the left of the queue. So the one that we popped, we can add back to the left side. ",
        "00:02:50,84"
    ],
    "33": [
        "And also we can choose to pop from the right side if we want to. So running this, we can confirm that the one is added back, and then we pop the two afterthat. Hash sets are really useful because we can search them in constant time, and we can insertvalues also in constant time. Of course, there won't be any duplicates in our set. Of course, unlike a list, there can't be any duplicates in a hash set. But we can just as easily get the length of the hash set to know how many elements havebeen inserted. We can also search the hash set. Without a function, we can use the in operator. So if we want to know if one exists in the hash set, same thing with two, same thingwith three, which we know does not exist in the hash set, as we can confirm. ",
        "00:03:14,96"
    ],
    "34": [
        "We can remove values also in constant time and confirm that the value has indeed beenremoved. To initialize a hash set with a bunch of values, we can actually pass in a list. But just like with lists, we can also do set comprehension and manually initialize it witha loop inside of the hash set. So here we're going through every value in the range of i and taking that value i, addingit to the hash set, and initializing it this way is identical. Hash maps are probably the single most common data structure you're going to be used, andthis is what we were saving those curly braces for. To insert, we simply take some key value, in this case a string, and assign it to anothervalue, in this case a number, 88. ",
        "00:03:56,22"
    ],
    "35": [
        "And we can add a bunch more. Just like with hash sets, we can't have duplicate keys inside of the hash map. Printing it is just as simple. Taking the length will give us the number of keys that exist in our hash map. We can modify the value that's mapped to a key, so we can change Alice from being 88to 80. We can also search if a key exists in a hash map in constant time, and we can also removethat key, which will also remove the value, as we can confirm on the right. To initialize a hash map, we can add pairs inside of the curly braces, where each pairis separated by a comma, and the key goes on the left side of the colon, and the valuegoes on the right side. This is the same as manually inserting values into the hash map. But if you want to get even more fancy, you can use dict comprehension. ",
        "00:04:35,66"
    ],
    "36": [
        "This is pretty powerful, and I find that I use it most frequently when I'm doing graphproblems and trying to build an adjacency list. Looping through a map is pretty interesting, because there's many ways to do it. By default, we iterate through every single key, and then we can print that key, and alsoprint the value that that key maps to. But also, we can directly iterate through the list of values of that hash map, if wedon't even need the key. Lastly, using unpacking, we can actually go through the items of that map, which willgive us the key and the value. ",
        "00:05:36,04"
    ],
    "37": [
        "This is pretty similar to the first loop that we have, I guess it's a bit more concise towrite it this way. Python also has tuples, which are pretty similar to arrays, except to initialize them we useparentheses rather than brackets, and they are immutable. So while we can index them, we can't modify them, so this won't work. You'll mainly be using tuples as keys for a hash map or a hash set, so in this casewe're mapping a pair of values 1, 2 to 3. So this tuple is basically our hashable key. We can do the same thing for hash sets, of course. And then we can use that tuple to search the hash set. The reason we do this is because lists are not hashable and can't be keys for hash setsor hash maps, so this here will not work. ",
        "00:06:07,32"
    ],
    "38": [
        "Heaps are another really common data structure to find the min and max of a set of valuesfrequently. Under the hood in Python, they're implemented with arrays, of course. So actually. . . для создания бездельного хипа мы просто создаем бездельный списоки для вывода цифр к этому хипу мы используемheapq. heapили в пайтоне это называется heapifyтак что мы можем называть heapq.  одна функциональностькоторую я использую много в кодинговых интервьюх, этонестовые функции.  одна вещь, котораяочень часто привлекает людей к нестовым функциям,это то, что вы можете изменить объекты, но вы не можетеперенести значения, если выиспользуете нестовый код.  это работаети будет подавлять оригинальную аррею,но если мы разделим значение, онобудет подавлять значение в скорпусефункции помощника.  если вы хотите подавлятьзначение за счет скорпуса помощника,вы должны заявить его как ненастоящийзначение, и делать это, и затемизменить значение, это измениторигинальную аррею. ",
        "00:07:11,68"
    ],
    "39": [
        " и потом ввнешнем функции мы можем назвать функцию помощника,без перенесения вариантов, и потомпринести варианты.  а теперь, чтобы назватьдвойную функцию, мы можем создать несколько вариантов,назвать, запустить код, и мы можем увидеть,что каждый вариант былподавлен.  опять же, это тривиальная пример,но если вы знакомы с моими видео, вы знаете,что это может быть полезно.  классытоже довольно конкретные, но немногоограничены от других языков. конструктор, в основном,двойной вариант,это название конструкторав пайтоне. ",
        "00:03:03,00"
    ],
    "40": [
        " селф вводится вкаждый метод класса.  этов основном, как в коде в других языках. в этом случае, наш конструктор, может быть,берет список чисел. чтобы создать варианты членов, мытакже используем код селфа. мы создаем вариант члена,который называется num, и мы его вводимв параметры конструктора. мы также можем создатьвариант члена для размерачленов, беряя длину параметра. чтобы создать метод для этого класса,например, getLength, мы не хотимвводить в него параметры, номы должны вводить в него слово self,всегда.  это дает нам доступ к варианту члена,который мы вернем, self. ",
        "00:03:35,00"
    ],
    "41": [
        "size. если мы хотим вызватьеще один вариант члена,в этом случае мы хотим вызватьgetLength от этого другого функции,getDoubleLength, мы можем сделать этоснова с кодом self. это довольно бесполезный пример, но яхочу объяснить синтез иструктуру классов в Python. это примерно все, что мне нужно знатьдля кодирования интервью. удивительно, это не много. и вы не должны запомнить это. когда вы решаете кодирование проблем,и готовитесь к интервью, вы должныпосмотреть синтез, или как я используюдвойные кодирования, и так далее. это отлично, но после того, каквы практикуете достаточно, большинство этогодовольно легко уйдет.  даже не чувствуется,как вы пишете код после некоторого времени. Python это довольно большой причиной,для чего я смог получить работу в Google, в моем мнении. теперь, если вы готовитесь к кодированию интервью,посмотрите на neatcode. ",
        "00:04:51,96"
    ],
    "42": [
        "io. там много бесплатных ресурсов, чтобы помочь вам подготовиться. каждый проблем, который я списал,имеет подробную объяснение в видео. и у нас есть поддержка кодов для Python, C++,Java и JavaScript. в связи с данными структур и алгоритмами,у меня есть очень полезные курсы,не только для начинающих, но и для улучшенных пользователей. ",
        "00:01:01,32"
    ],
    "43": [
        "спасибо за просмотр, и надеюсь,я увиду вас скоро. . . . ",
        "00:05:15,00"
    ]
}